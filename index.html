<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      body {
        background-color: #ffffff;
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <!--
  
 /  |      /  |      /         /  |
(___|     (   |     (         (___|  
    )     |   )     |   )     |\     
 __/      |__/      |__/      | \  
                                       http://yolk.cc          
  forked from threejs example:
  https://github.com/mrdoob/three.js/blob/master/examples/webgl_animation_cloth.html
                   
                   
  -->
  <body>
    
    <script src="http://brangerbriz.net/labs/threejs_playGnd/js/three.min.js"></script>
    <script src="http://brangerbriz.net/labs/threejs_playGnd/js/Detector.js"></script>
    <script type="x-shader/x-vertex" id="vertexShaderDepth">

      varying vec2 vUV;

      void main() {

        vUV = 0.75 * uv;

        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

        gl_Position = projectionMatrix * mvPosition;

      }

    </script>
    <script type="x-shader/x-fragment" id="fragmentShaderDepth">

      uniform sampler2D texture;
      varying vec2 vUV;

      vec4 pack_depth( const in float depth ) {

        const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );
        const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );
        vec4 res = fract( depth * bit_shift );
        res -= res.xxyz * bit_mask;
        return res;

      }

      void main() {

        vec4 pixel = texture2D( texture, vUV );

        if ( pixel.a < 0.5 ) discard;

        gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );

      }
    </script>

    <script type="x-shader/x-vertex" id="vertexShaderDepth">

      varying vec2 vUV;

      void main() {

        vUV = 0.75 * uv;

        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

        gl_Position = projectionMatrix * mvPosition;

      }

    </script>

    <script>
      /*
       * Cloth Simulation using a relaxed constrains solver
       */

      // Suggested Readings

      // Advanced Character Physics by Thomas Jakobsen Character
      // http://freespace.virgin.net/hugo.elias/models/m_cloth.htm
      // http://en.wikipedia.org/wiki/Cloth_modeling
      // http://cg.alexandra.dk/tag/spring-mass-system/
      // Real-time Cloth Animation http://www.darwin3d.com/gamedev/articles/col0599.pdf

      var DAMPING = 0.03;
      var DRAG = 1 - DAMPING;
      var MASS = .1;
      var restDistance = 25;


      var xSegs = 10; //
      var ySegs = 10; //

      var clothFunction = plane(restDistance * xSegs, restDistance * ySegs);

      var cloth = new Cloth(xSegs, ySegs);

      var GRAVITY = 981 * 1.4; // 
      var gravity = new THREE.Vector3( 0, -GRAVITY, 0 ).multiplyScalar(MASS);


      var TIMESTEP = 18 / 1000;
      var TIMESTEP_SQ = TIMESTEP * TIMESTEP;

      var pins = [];


      var wind = true;
      var windStrength = 0.1;
      var windForce = new THREE.Vector3(0,0,0);

      var ballPosition = new THREE.Vector3(0, -45, 0);
      var ballSize = 10; //40

      var tmpForce = new THREE.Vector3();

      var lastTime;


      function plane(width, height) {

        return function(u, v) {
          var x = (u-0.5) * width;
          var y = (v+0.5) * height;
          var z = 0;

          return new THREE.Vector3(x, y, z);
        };
      }

      function Particle(x, y, z, mass) {
        this.position = clothFunction(x, y); // position
        this.previous = clothFunction(x, y); // previous
        this.original = clothFunction(x, y); 
        this.a = new THREE.Vector3(0, 0, 0); // acceleration
        this.mass = mass;
        this.invMass = 1 / mass;
        this.tmp = new THREE.Vector3();
        this.tmp2 = new THREE.Vector3();
      }

      // Force -> Acceleration
      Particle.prototype.addForce = function(force) {
        this.a.add(
          this.tmp2.copy(force).multiplyScalar(this.invMass)
        );
      };


      // Performs verlet integration
      Particle.prototype.integrate = function(timesq) {
        var newPos = this.tmp.subVectors(this.position, this.previous);
        newPos.multiplyScalar(DRAG).add(this.position);
        newPos.add(this.a.multiplyScalar(timesq));

        this.tmp = this.previous;
        this.previous = this.position;
        this.position = newPos;

        this.a.set(0, 0, 0);
      }


      var diff = new THREE.Vector3();

      function satisifyConstrains(p1, p2, distance) {
        diff.subVectors(p2.position, p1.position);
        var currentDist = diff.length();
        if (currentDist==0) return; // prevents division by 0
        var correction = diff.multiplyScalar(1 - distance/currentDist);
        var correctionHalf = correction.multiplyScalar(0.5);
        p1.position.add(correctionHalf);
        p2.position.sub(correctionHalf);
      }


      function Cloth(w, h) {
        w = w || 10;
        h = h || 10;
        this.w = w;
        this.h = h;

        var particles = [];
        var constrains = [];

        var u, v;

        // Create particles
        for (v=0;v<=h;v++) {
          for (u=0;u<=w;u++) {
            particles.push(
              new Particle(u/w, v/h, 0, MASS)
            );
          }
        }

        // Structural

        for (v=0;v<h;v++) {
          for (u=0;u<w;u++) {

            constrains.push([
              particles[index(u, v)],
              particles[index(u, v+1)],
              restDistance
            ]);

            constrains.push([
              particles[index(u, v)],
              particles[index(u+1, v)],
              restDistance
            ]);

          }
        }

        for (u=w, v=0;v<h;v++) {
          constrains.push([
            particles[index(u, v)],
            particles[index(u, v+1)],
            restDistance

          ]);
        }

        for (v=h, u=0;u<w;u++) {
          constrains.push([
            particles[index(u, v)],
            particles[index(u+1, v)],
            restDistance
          ]);
        }


        // While many system uses shear and bend springs,
        // the relax constrains model seem to be just fine
        // using structural springs.
        // Shear
        // var diagonalDist = Math.sqrt(restDistance * restDistance * 2);


        // for (v=0;v<h;v++) {
        //  for (u=0;u<w;u++) {

        //    constrains.push([
        //      particles[index(u, v)],
        //      particles[index(u+1, v+1)],
        //      diagonalDist
        //    ]);

        //    constrains.push([
        //      particles[index(u+1, v)],
        //      particles[index(u, v+1)],
        //      diagonalDist
        //    ]);

        //  }
        // }


        this.particles = particles;
        this.constrains = constrains;

        function index(u, v) {
          return u + v * (w + 1);
        }

        this.index = index;

      }

      function simulate(time) {
        if (!lastTime) {
          lastTime = time;
          return;
        }
        
        var i, il, particles, particle, pt, constrains, constrain;

        // Aerodynamics forces
        if (wind) {
          var face, faces = clothGeometry.faces, normal;

          particles = cloth.particles;

          for (i=0,il=faces.length;i<il;i++) {
            face = faces[i];
            normal = face.normal;

            tmpForce.copy(normal).normalize().multiplyScalar(normal.dot(windForce));
            particles[face.a].addForce(tmpForce);
            particles[face.b].addForce(tmpForce);
            particles[face.c].addForce(tmpForce);
          }
        }
        
        for (particles = cloth.particles, i=0, il = particles.length
            ;i<il;i++) {
          particle = particles[i];
          particle.addForce(gravity);

          particle.integrate(TIMESTEP_SQ);
        }

        // Start Constrains

        constrains = cloth.constrains,
        il = constrains.length;
        for (i=0;i<il;i++) {
          constrain = constrains[i];
          satisifyConstrains(constrain[0], constrain[1], constrain[2]);
        }

        // Ball Constrains


        ballPosition.z = -Math.sin(Date.now()/600) * 90 ; //+ 40;
        ballPosition.x = Math.cos(Date.now()/400) * 70

        
        for (particles = cloth.particles, i=0, il = particles.length
            ;i<il;i++) {
          particle = particles[i];
          pos = particle.position;
          diff.subVectors(pos, ballPosition);
          if (diff.length() < ballSize) {
            // collided
            diff.normalize().multiplyScalar(ballSize);
            pos.copy(ballPosition).add(diff);
          }
        }

        // Floor Constains
        for (particles = cloth.particles, i=0, il = particles.length
            ;i<il;i++) {
          particle = particles[i];
          pos = particle.position;
          if (pos.y < -250) {
            pos.y = -250;
          }
        }

        // Pin Constrains
        for (i=0, il=pins.length;i<il;i++) {
          var xy = pins[i];
          var p = particles[xy];
          p.position.copy(p.original);
          p.previous.copy(p.original);
        }


      }
    </script>
    <script>

      var pinsFormation = [];
      var pins = [6];

      pinsFormation.push( pins );

      pins = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
      pinsFormation.push( pins );

      pins = [ 0 ];
      pinsFormation.push( pins );

      pins = []; // cut the rope ;)
      pinsFormation.push( pins );

      pins = [ 0, cloth.w ]; // classic 2 pins
      pinsFormation.push( pins );

      pins = pinsFormation[ 1 ];

      if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
      

      var container, stats;
      var camera, scene, renderer;

      var clothGeometry;
      var sphere;
      var object, arrow;

      var rotate = true;
      function setup() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        // scene

        scene = new THREE.Scene();

        // scene.fog = new THREE.Fog( 0xcce0ff, 500, 10000 );

        // camera

        camera = new THREE.PerspectiveCamera( 15, window.innerWidth / window.innerHeight, 1, 10000 );
        camera.position.y = 0;
        camera.position.z = 9000;
        scene.add( camera );

        // lights

        var light, materials;

        scene.add( new THREE.AmbientLight( 0x666666 ) );

        light = new THREE.DirectionalLight( 0xdfebff, 1.75 );
        light.position.set( 50, 200, 100 );
        light.position.multiplyScalar( 1.3 );

        light.castShadow = true;
        //light.shadowCameraVisible = true;

        light.shadowMapWidth = 2048 * 2;
        light.shadowMapHeight = 2048 * 2;

        var d = 400;

        light.shadowCameraLeft = -d;
        light.shadowCameraRight = d;
        light.shadowCameraTop = d;
        light.shadowCameraBottom = -d;

        light.shadowCameraFar = 1000;
        light.shadowDarkness = 0.5;

        scene.add( light );

        light = new THREE.DirectionalLight( 0x3dff0c, 0.35 );
        light.position.set( 0, -1, 0 );

        scene.add( light );

        // cloth material

        var clothTexture = THREE.ImageUtils.loadTexture( "http://i.imgur.com/eIBV3iy.png?1" );
        clothTexture.wrapS = clothTexture.wrapT = THREE.RepeatWrapping;
        clothTexture.anisotropy = 16;

        var clothMaterial = new THREE.MeshPhongMaterial( { alphaTest: 0.5, ambient: 0xffffff, color: 0xffffff, specular: 0x030303, emissive: 0x111111, shiness: 10, map: clothTexture, side: THREE.DoubleSide } );

        // cloth geometry
        clothGeometry = new THREE.ParametricGeometry( clothFunction, cloth.w, cloth.h, true );
        clothGeometry.dynamic = true;
        clothGeometry.computeFaceNormals();

        var uniforms = { texture:  { type: "t", value: clothTexture } };
        var vertexShader = document.getElementById( 'vertexShaderDepth' ).textContent;
        var fragmentShader = document.getElementById( 'fragmentShaderDepth' ).textContent;

        // cloth mesh

        object = new THREE.Mesh( clothGeometry, clothMaterial );
        object.position.set( 0, 0, 0 );
        object.castShadow = true;
        object.receiveShadow = true;
        scene.add( object );

        object.customDepthMaterial = new THREE.ShaderMaterial( { uniforms: uniforms, vertexShader: vertexShader, fragmentShader: fragmentShader } );

        // sphere

        var ballGeo = new THREE.SphereGeometry( ballSize, 20, 20 );
        var ballMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );

        sphere = new THREE.Mesh( ballGeo, ballMaterial );
        sphere.castShadow = true;
        sphere.receiveShadow = true;
        // scene.add( sphere );

        // arrow

        arrow = new THREE.ArrowHelper( new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 0 ), 50, 0xff0000 );
        arrow.position.set( -200, 0, -200 );
        // scene.add( arrow );

        // ground

        var initColor = new THREE.Color( 0x000000 );
        var initTexture = THREE.ImageUtils.generateDataTexture( 0, 0, initColor );

        var groundMaterial = new THREE.MeshPhongMaterial( { color: 0x000000, specular: 0x000000, map: initTexture } );

        var groundTexture = THREE.ImageUtils.loadTexture( "http://placehold.it/250/e3e3e3/e3e3e3", undefined, function() { groundMaterial.map = groundTexture } );
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set( 1, 1 );
        groundTexture.anisotropy = 0;

        var mesh = new THREE.Mesh( new THREE.PlaneGeometry( 20000, 20000 ), groundMaterial );
        mesh.position.y = -250;
        mesh.rotation.x = - Math.PI / 2;
        mesh.receiveShadow = true;
        scene.add( mesh );

        // poles

        // var poleGeo = new THREE.CubeGeometry( 5, 375, 5 );
        // var poleMat = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0x111111, shiness: 100 } );

        // var mesh = new THREE.Mesh( poleGeo, poleMat );
        // mesh.position.x = -125;
        // mesh.position.y = -62;
        // mesh.receiveShadow = true;
        // mesh.castShadow = true;
        // scene.add( mesh );

        // var mesh = new THREE.Mesh( poleGeo, poleMat );
        // mesh.position.x = 125;
        // mesh.position.y = -62;
        // mesh.receiveShadow = true;
        // mesh.castShadow = true;
        // scene.add( mesh );

        // var mesh = new THREE.Mesh( new THREE.CubeGeometry( 255, 5, 5 ), poleMat );
        // mesh.position.y = -250 + 750/2;
        // mesh.position.x = 0;
        // mesh.receiveShadow = true;
        // mesh.castShadow = true;
        // scene.add( mesh );

        // var gg = new THREE.CubeGeometry( 10, 10, 10 );
        // var mesh = new THREE.Mesh( gg, poleMat );
        // mesh.position.y = -250;
        // mesh.position.x = 125;
        // mesh.receiveShadow = true;
        // mesh.castShadow = true;
        // scene.add( mesh );

        // var mesh = new THREE.Mesh( gg, poleMat );
        // mesh.position.y = -250;
        // mesh.position.x = -125;
        // mesh.receiveShadow = true;
        // mesh.castShadow = true;
        // scene.add( mesh );

        

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setSize( window.innerWidth, window.innerHeight );
        // renderer.setClearColor( scene.fog.color );

        container.appendChild( renderer.domElement );

        renderer.gammaInput = true;
        renderer.gammaOutput = true;
        renderer.physicallyBasedShading = true;

        renderer.shadowMapEnabled = true;
      }

      function draw() {

        requestAnimationFrame( draw );
        

        var time = Date.now();

        windStrength = Math.cos( time / 7000 ) * 20 + 40;
        windForce.set( Math.sin( time / 2000 ), Math.cos( time / 30000 ), Math.sin( time / 10000 ) ).normalize().multiplyScalar( windStrength );

        simulate(time);
        render();
        renderer.render( scene, camera );

      }

      function render() {

        var timer = Date.now() * 0.0002;

        var p = cloth.particles;

        for ( var i = 0, il = p.length; i < il; i ++ ) {

          clothGeometry.vertices[ i ].copy( p[ i ].position );

        }

        clothGeometry.computeFaceNormals();
        clothGeometry.computeVertexNormals();

        clothGeometry.normalsNeedUpdate = true;
        clothGeometry.verticesNeedUpdate = true;

        sphere.position.copy( ballPosition );

        // if ( rotate ) {

        //   camera.position.x = Math.cos( timer ) * 1500;
        //   camera.position.z = Math.sin( timer ) * 1500;

        // }
        camera.position.x = camera.position.z = 999;
      camera.position.y = 100;

        camera.lookAt( scene.position );

        renderer.render( scene, camera );

      }
      setup();
      draw();

    </script>
    
  </body>
</html>